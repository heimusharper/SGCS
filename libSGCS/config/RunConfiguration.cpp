/*
 * This file is part of the SGCS distribution (https://github.com/heimusharper/SGCS).
 * Copyright (c) 2020 Andrey Stepanov.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
#include "RunConfiguration.h"
#include "version.h"

ConfigInterface::ConfigInterface(ConfigInterface *root) : _parent(root)
{
}

ConfigInterface *ConfigInterface::parent() const
{
    return _parent;
}

void ConfigInterface::save()
{
    if (_parent)
        _parent->save();
}

//

ApplicationConfiguration::ApplicationConfiguration(ConfigInterface *parent)
: ConfigInterface(parent)
// init from autogenerated version.h
, m_versionMajor(SGCS_VERSION_MAJOR)
, m_versionMinor(SGCS_VERSION_MINOR)
, m_versionPath(SGCS_VERSION_PATH)
, m_versionHash(SGCS_VERSION_HASH)
, m_startDatasource(std::string())
{
}

std::string ApplicationConfiguration::name() const
{
    return "ApplicationConfiguration";
}

YAML::Node ApplicationConfiguration::toNode(const YAML::Node &file) const
{
    YAML::Node node                     = file;
    node["run_profile_name"]            = m_profile;
    node["datasource_autostart_plugin"] = m_startDatasource;
    return node;
}

void ApplicationConfiguration::fromNode(const YAML::Node &node)
{
    if (node["run_profile_name"])
        m_profile = node["run_profile_name"].as<std::string>();
    else
        m_profile = "default";
    if (node["datasource_autostart_plugin"])
        m_startDatasource = node["datasource_autostart_plugin"].as<std::string>();
    else
        m_startDatasource = "";
}

std::string ApplicationConfiguration::profile() const
{
    return m_profile;
}

void ApplicationConfiguration::setProfile(const std::string &profile)
{
    m_profile = profile;
}

int ApplicationConfiguration::versionMajor() const
{
    return m_versionMajor;
}

int ApplicationConfiguration::versionMinor() const
{
    return m_versionMinor;
}

int ApplicationConfiguration::versionPath() const
{
    return m_versionPath;
}

std::string ApplicationConfiguration::versionHash() const
{
    return m_versionHash;
}

std::string ApplicationConfiguration::startDatasource() const
{
    return m_startDatasource;
}

void ApplicationConfiguration::setStartDatasource(const std::string &startDatasource)
{
    m_startDatasource = startDatasource;
}

//
RunConfiguration::RunConfiguration(ConfigInterface *root) : ConfigInterface(root)
{
}

RunConfiguration::~RunConfiguration()
{
    save();
    clear();
}

RunConfiguration &RunConfiguration::instance()
{
    static RunConfiguration rc;
    return rc;
}

bool RunConfiguration::create(const std::string &filename)
{
    _filename = filename;
    try
    {
        // open YAML file
        _yaml = YAML::LoadFile(filename);
        fromNode(_yaml);
        return true;
    }
    catch (YAML::Exception &e)
    {
        BOOST_LOG_TRIVIAL(warning) << "YAML EXCEPTION " << filename << e.what();
    }
    return false;
}

std::string RunConfiguration::name() const
{
    return "RunConfiguration";
}

YAML::Node RunConfiguration::toNode(const YAML::Node &file) const
{
    YAML::Node root = file;
    // all childs
    for (const ConfigInterface *node : _nodes)
        root[node->name()] = node->toNode(root[node->name()]);
    return root;
}

void RunConfiguration::fromNode(const YAML::Node &node)
{
    // all childs
    for (ConfigInterface *i : _nodes)
        if (node[i->name()])
            i->fromNode(node[i->name()]);
}

YAML::Node RunConfiguration::getFromFile(const std::string &link)
{
    try
    {
        if (_yaml[link])
            return _yaml[link];
    }
    catch (YAML::BadFile &e)
    {
        BOOST_LOG_TRIVIAL(warning) << "YAML BAD FILE" << e.what() << " tree " << link;
        save();
        return getFromFile(link);
    }
    YAML::Node n;
    _yaml[link] = n;
    return n;
}

void RunConfiguration::forceSave()
{
    save();
}

void RunConfiguration::clear()
{
    while (!_nodes.empty())
    {
        auto obj = _nodes.back();
        _nodes.pop_back();
        delete obj;
    }
}

void RunConfiguration::save()
{
    _yaml = toNode(_yaml);
    std::ofstream fout(_filename);
    fout << _yaml;
}
