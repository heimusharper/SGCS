/*
 * This file is part of the SGCS distribution (https://github.com/heimusharper/SGCS).
 * Copyright (c) 2020 Andrey Stepanov.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
#include "RunConfiguration.h"
#include "version.h"

ConfigInterface::ConfigInterface(ConfigInterface *root) : _parent(root)
{
}

ConfigInterface *ConfigInterface::parent() const
{
    return _parent;
}

void ConfigInterface::save()
{
    if (_parent)
        _parent->save();
}

//

ApplicationConfiguration::ApplicationConfiguration(ConfigInterface *parent)
: ConfigInterface(parent)
// init from autogenerated version.h
, m_versionMajor(SGCS_VERSION_MAJOR)
, m_versionMinor(SGCS_VERSION_MINOR)
, m_versionPath(SGCS_VERSION_PATH)
, m_versionHash(SGCS_VERSION_HASH)
, m_startDatasource(QString())
{
}

QString ApplicationConfiguration::name() const
{
    return "ApplicationConfiguration";
}

YAML::Node ApplicationConfiguration::toNode(const YAML::Node &file) const
{
    YAML::Node node                     = file;
    node["run_profile_name"]            = m_profile.toStdString();
    node["datasource_autostart_plugin"] = m_startDatasource.toStdString();
    return node;
}

void ApplicationConfiguration::fromNode(const YAML::Node &node)
{
    if (node["run_profile_name"])
        m_profile = QString::fromStdString(node["run_profile_name"].as<std::string>());
    else
        m_profile = "default";
    if (node["datasource_autostart_plugin"])
        m_startDatasource = QString::fromStdString(node["datasource_autostart_plugin"].as<std::string>());
    else
        m_startDatasource = "";
}

QString ApplicationConfiguration::profile() const
{
    return m_profile;
}

void ApplicationConfiguration::setProfile(const QString &profile)
{
    m_profile = profile;
}

int ApplicationConfiguration::versionMajor() const
{
    return m_versionMajor;
}

int ApplicationConfiguration::versionMinor() const
{
    return m_versionMinor;
}

int ApplicationConfiguration::versionPath() const
{
    return m_versionPath;
}

QString ApplicationConfiguration::versionHash() const
{
    return m_versionHash;
}

QString ApplicationConfiguration::startDatasource() const
{
    return m_startDatasource;
}

void ApplicationConfiguration::setStartDatasource(const QString &startDatasource)
{
    m_startDatasource = startDatasource;
}

//
RunConfiguration::RunConfiguration(ConfigInterface *root) : ConfigInterface(root)
{
}

RunConfiguration::~RunConfiguration()
{
    save();
    clear();
}

RunConfiguration &RunConfiguration::instance()
{
    static RunConfiguration rc;
    return rc;
}

bool RunConfiguration::create(const QString &filename)
{
    _filename = filename;
    try
    {
        // open YAML file
        _yaml = YAML::LoadFile(filename.toStdString());
        fromNode(_yaml);
        return true;
    }
    catch (YAML::Exception &e)
    {
        qWarning() << "YAML EXCEPTION " << filename << QString(e.what());
    }
    return false;
}

QString RunConfiguration::name() const
{
    return "RunConfiguration";
}

YAML::Node RunConfiguration::toNode(const YAML::Node &file) const
{
    YAML::Node root = file;
    // all childs
    for (const ConfigInterface *node : _nodes)
        root[node->name().toStdString()] = node->toNode(root[node->name().toStdString()]);
    return root;
}

void RunConfiguration::fromNode(const YAML::Node &node)
{
    // all childs
    for (ConfigInterface *i : _nodes)
        if (node[i->name().toStdString()])
            i->fromNode(node[i->name().toStdString()]);
}

YAML::Node RunConfiguration::getFromFile(const QString &link)
{
    try
    {
        if (_yaml[link.toStdString()])
            return _yaml[link.toStdString()];
    }
    catch (YAML::BadFile &e)
    {
        qWarning() << "YAML BAD FILE" << QString(e.what()) << " tree " << link;
        save();
        return getFromFile(link);
    }
    YAML::Node n;
    _yaml[link.toStdString()] = n;
    return n;
}

void RunConfiguration::forceSave()
{
    save();
}

void RunConfiguration::clear()
{
    while (!_nodes.isEmpty())
    {
        auto obj = _nodes.takeFirst();
        // obj->clear();
        delete obj;
    }
}

void RunConfiguration::save()
{
    _yaml = toNode(_yaml);
    std::ofstream fout(_filename.toStdString());
    fout << _yaml;
}
